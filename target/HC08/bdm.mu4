( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2009 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

cr " HCS08 BDM support " file[#

( Support for Freescale's Background Debug Mode - or BDM.)

( I originially wrote this code "flattened" out but I want to run it from
  the small RAM in a 908, and it won't fit. I don't see why I can't make
  the bit transmit and receive code _routines_ rather than macros. What
  matters is the timing _within_ a bit, not as much between bits. As long
  as no more than 512 cycles elapse between falling edges, the interface
  will not time out.)

( Compressing three transitions into one byte:
   Hxx  10
   xHx  08
   xxH  04
   Lxx  80
   xLx  40
   xxL  20
                    L  H
   tx1 = LHH = 8c = 1000_1100
   tx0 = LLH = c4 = 1100_0100  )

-- macro savex   xSaved ) stx  ;m
-- macro restx   xSaved ) ldx  ;m
macro savex   .x psh  ;m
macro restx   .x pul  ;m

( Send one bit via BDM.)
code tx1  ( tx bit in A)
   savex  PBD # ldx
   0 ,x sta   .a lsl   0 ,x sta  .a lsl  0 ,x sta
   restx  rts  ;c

( Send one byte via BDM.)
code tx8  ( tx byte in A)
   ( loop 8; generate bits MSB first)
   0 ,x sta   8 # lda   1 ,x sta
   begin  0 ,x rol  CS if  8c # lda  else  0c4 # lda  then
      tx1 bsr   1 ,x decz?  until
   rts  ;c

( Recv one bit via BDM.)
code rx1  ( recvd bit in A1)
   savex  PBD # ldx
   80 # lda ( BKGD_L)   0 ,x sta   .a lsl   0 ,x sta   PA ) lda
   restx  rts  ;c

( Recv one byte via BDM.)
code rx8  ( recvd byte in A)
   ( loop 8; recv bits MSB first; bit is 02)
   8 # lda   1 ,x sta   0 ,x clr
   begin   rx1 bsr   .a ror  .a ror  ( PA1 -> C)  0 ,x rol
           1 ,x decz?  until
   0 ,x lda  ( byte into A)
   rts  ;c

code InitBdm
   10 # PB ) mov   -- BKGD_L 0, BKGD_H 1
   PBD ) clr
   rts  ;c

0 [if]
( Archive this here.)

( Send one bit via BDM.)
macro tx1
   .a pul   0 ,x sta   .a lsl   0 ,x sta  .a lsl  0 ,x sta  ;m

( Recv one bit via BDM.)
macro rx1
   80 # lda ( BKGD_L)   0 ,x sta   .a lsl   0 ,x sta   PB ) lda   .a psh  ;m

macro savex   xSaved ) stx  ;m
macro restx   xSaved ) ldx  ;m

code tx8
   ( loop 8; generate bits LSB first; then we'll pop them MSB first)
   8 # lda   0 ,x sta
   begin  2 ,x ror  CS if  8c # lda  else  0c4 # lda  then
          .a psh  0 ,x decz?  until
   savex  ( XXX if I moved this above the pushes, it could psh onto stack...)
   PBD # ldx
   tx1  tx1  tx1  tx1
   tx1  tx1  tx1  tx1
   restx   2 # aix  ( pop xmitted byte)
   rts  ;c

code rx8
   savex
   PBD # ldx
   rx1  rx1  rx1  rx1
   rx1  rx1  rx1  rx1
   restx
   ( loop 8; pop bits LSB first; bit is 02)
   8 # lda   1 ,x sta   0 ,x clr
   begin   .a pul  .a ror  .a ror  ( PA2 -> C)  0 ,x ror
           1 ,x decz?  until
   -2 # aix  ( promote scratch - recvd char - to TOP)
   rts  ;c

[then]

#]file
